<h1 align="center"><img height="40" src="https://github.com/Aquiles369/iconos/blob/main/img/lobo1.gif"><img height="40" src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExNWx4YTl1dW9scXlqZDk2cTdyY2VvcXQwMG40OGoxY25rZzV0MDZhcCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/peSyJWjNTRfzaWh49M/giphy.gif">".js analisis"<img height="40" src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExNWx4YTl1dW9scXlqZDk2cTdyY2VvcXQwMG40OGoxY25rZzV0MDZhcCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/peSyJWjNTRfzaWh49M/giphy.gif"><img height="35" src="https://github.com/Aquiles369/iconos/blob/main/img/lobo1.gif"> </h1>	


<br>


<p align="center">
 <img  height="470rem" alt="GIF" src="https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExaGRxd2VjOWdjNm11bmJoa2ZlNGdwMGxpdmRuNmNkMHZ6am5sOHBreiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/jRf4JCqluUqIV8AfLm/giphy.gif"/>
</p>


<picture> <img src="https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif">  </picture>

 ### <picture> <img src = "https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExcDl3ZHMzbDdvc3Q4bnJtd3d0Y3BwNHNucGh5NG02MWcxNHpxdWp4aCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/njQOl2ZDhznxW60OBK/giphy.gif" width = 75px>  </picture> Analisis de archivos .js

<br>

 **Análisis de archivos .js. Proceso enfocado en revisar, mapear y comprender el código JavaScript de una aplicación para identificar vectores de ataque potenciales. Incluye la detección de funciones sensibles, endpoints ocultos, parámetros interesantes, lógica de validación, fugas de datos y posibles superficies para XSS, DOM Clobbering, prototipo pollution o bypass de seguridad.<br><br>
Objetivo: convertir cada archivo .js en una fuente de inteligencia útil durante la fase de recon y explotación, revelando rutas y comportamientos que no están expuestos directamente en la interfaz de la aplicación.** 
<br><br> 

<p align="center">
 <img  height="420rem" alt="GIF" src="https://github.com/Aquiles369/iconos/blob/main/metodos_http_y_header_demo_1.gif"/>
</p>


<br>
<picture> <img src="https://user-images.githubusercontent.com/74038190/212284115-f47cd8ff-2ffb-4b04-b5bf-4d1c14c0247f.gif" width ="1050" > </picture>
<br>


### <picture> <img src = "https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExb3V4NGRlcHkzNGdqbWd2bjBzdHVlNDRoMmNwdmVxOW14OGlibjBzaSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/EF0aNcNeR9R7CW3sFq/giphy.gif" width = 75px>  </picture> Problema que resuelve<br><br>
**En bug bounty y auditorías web, los informes terminan desperdigados entre tickets, wikis, tabs del navegador y notas sueltas. Clasificar, priorizar (“leo ya o después”), anotar contexto y abrir en lote sin depender de un backend suele ser un dolor.<br><br>
• Este gestor te quita ese caos con un entorno totalmente offline, simple y visual: creás categorías, cargás informes/URLs, los priorizás con etiquetas claras, sumás notas (con última edición), abrís un informe o un lote filtrado en un par de clics y te llevás todo como JSON cuando quieras.</a>.** 

<br>

### <picture> <img src = "https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExbGYwNzBkM2ZsOWl2bThodzg5bW5haTJpNGYwaTdvZ21zd3pvZ2x0NyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/YARSS5UwRLZtcQHXzp/giphy.gif" width = 75px>  </picture> Qué aporta y cómo beneficia <br><br>
**• Orden quirúrgico de tus informes: categorías personalizadas (XSS, IDOR, RCE, etc.), renglones con título editable y URL, y etiquetas que te dicen qué leer primero.<br><br>
• Búsqueda y filtro instantáneos: panel lateral que busca por título, URL, nota o categoría. Filtro por estado para enfocarte en lo urgente o lo de “montón”.<br><br>
• Documentación táctica sin fricción: cada informe admite nota con contexto, fecha de última edición y tooltip flotante (previsualización segura).<br><br>
• Velocidad de ejecución: botón Abrir por renglón y opción Abrir TODOS (filtrados) con límite seguro (hasta 15 por clic para no pelear con bloqueadores). Exportás/importás JSON o reseteás en un clic.<br><br>
• Privacidad y resiliencia: funciona offline en tu navegador usando localStorage. Sin backend, sin instalación, ideal para labs aislados o entornos sensibles.<br><br>
• Más foco, menos tabitis: todo vive en un lugar. Menos tiempo buscando, más tiempo explotando (legalmente, obvio).</a>.** 

<br>
<picture> <img src="https://user-images.githubusercontent.com/74038190/212284115-f47cd8ff-2ffb-4b04-b5bf-4d1c14c0247f.gif" width ="1050" > </picture>
<br>

### <picture> <img src = "https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExbXF2ZmtjNHA1YnJ5bjR2dG8yMjhjbWw1aXJwazE0eW9qa2U4anVoNiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/Ha2DszQVpjI1AxvW5h/giphy.gif" width = 80px>  </picture> Resumen rápido
<br><br>

Tool offline en el navegador para gestionar informes/URLs de bug bounty.
Abrís el HTML y ya podés crear/editar/eliminar categorías, agregar renglones con informes, asignar etiquetas, filtrar, anotar, abrir individual o abrir todos los filtrados.<br><br>
Persistencia en localStorage; también exportar/importar JSON o reset total.
Los contenidos en tooltips se escapan (no se ejecuta nada), porque queremos informes, no un XSS auto-inflicto.<br>


• Formato: interfaz web local (HTML/JS). Data en localStorage (offline, en tu máquina).<br>


<br>
<picture> <img src="https://user-images.githubusercontent.com/74038190/212284115-f47cd8ff-2ffb-4b04-b5bf-4d1c14c0247f.gif" width ="1050" > </picture>
<br>

### <picture> <img src = "https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExcjdrZDd3eHBkaTloYXJ6dWYyNTV6bWhwZ3AwOG1xOWJ4cWtzbGhldyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/mGOfFjRCnoGPcLqYoA/giphy.gif" width = 80px>  </picture> “Checklist analisis de archivos .js ”



```yaml
CHECKLIST — ANÁLISIS OFENSIVO DE ARCHIVOS .JS
🧱 1. Enumeración completa de archivos JS

✅ Prueba clave:

Localizá todos los .js cargados por la app:

Con DevTools → pestaña Network (.js)

Con herramientas:

katana -u https://target.com -jc

subjs, linkfinder, JSFinder

Interpretación:

🟢 Solo librerías externas → ✅ superficie mínima.

🟡 Archivos internos pero minificados → ⚠️ potencial oculto.

🔴 JS internos no minificados → 🔥 info sensible accesible.

💡 Pro tip: buscá también .map (source maps), a veces revelan el código fuente completo sin minificar.

🧪 2. Búsqueda de endpoints y rutas internas

✅ Prueba clave:

Extraé URLs, paths y dominios embebidos:

/api/v1/users
https://internal.api.target.com
https://s3.amazonaws.com/target-bucket


Usá grep -Eo "https?://[^\"']+" *.js o linkfinder.py.

Interpretación:

🟢 Solo endpoints públicos conocidos → ✅ controlado.

🟡 Endpoints no documentados → ⚠️ recon útil.

🔴 Rutas internas o admin → 🔥 expansión de superficie.

💡 Encontrar /admin/backup o /api/internal/config en un .js = joya para cadenas de explotación.

🧰 3. Búsqueda de secretos, claves y tokens

✅ Prueba clave:

Buscá patrones comunes:

api_key
access_token
secret
Bearer
Basic


Regex pro:

[A-Za-z0-9_\-]{20,40}
AIza[0-9A-Za-z\-_]{35}


Interpretación:

🟢 Nada sensible → ✅ limpio.

🟡 Tokens revocados → ⚠️ leak informativo.

🔴 Claves válidas → 🔥 explotación directa (SSRF, RCE, admin takeover).

💡 En bug bounties reales, se han conseguido RCE en AWS Lambda con una simple key filtrada en un .js.

🪤 4. Detección de parámetros, query keys y payload sinks

✅ Prueba clave:

Identificá parámetros usados en requests JS:

fetch("/api/user?id="+userId)
xhr.open("GET", "/details?item="+item)


Interpretación:

🟢 Parámetros internos sin control del usuario → ✅ seguro.

🟡 Parámetros parcialmente controlables → ⚠️ probar inyección.

🔴 Parámetros 100% controlados por el usuario → 🔥 vector XSS, IDOR o inyección.

💡 Cada parámetro en un .js = posible punto de entrada. Combínalo con fuzzers o payloads manuales.

🧠 5. Identificación de sinks peligrosos y funciones críticas

✅ Prueba clave:

Buscá funciones que ejecutan o insertan contenido:

innerHTML
outerHTML
eval(
Function(
document.write(
setTimeout("...


Interpretación:

🟢 No se usan sinks peligrosos → ✅ superficie limitada.

🟡 Sinks presentes pero con sanitización → ⚠️ necesita bypass.

🔴 Sinks con input del usuario → 🔥 DOM XSS o RCE inminente.

💡 Esto convierte un simple parámetro reflejado en XSS funcional sin tocar el backend.

🛠️ 6. Análisis de lógica interna y bypasses potenciales

✅ Prueba clave:

Leé la lógica de funciones sensibles:

Validaciones (if (role === 'admin'))

Flags (debug=true)

Checks ocultos (if(!isVerified))

Interpretación:

🟢 Lógica clara y robusta → ✅ bien estructurado.

🟡 Validaciones solo en frontend → ⚠️ bypass fácil.

🔴 Acciones críticas sin verificación → 🔥 abuso directo.

💡 Muchas apps validan roles solo en el JS → podés cambiar user por admin desde la consola y acceder a paneles protegidos 😏

🧪 7. Revisión de dependencias vulnerables

✅ Prueba clave:

Buscá versiones de librerías:

<script src="https://cdn.jsdelivr.net/npm/jquery@1.8.3"></script>


Chequeá CVEs con npm audit o Snyk
.

Interpretación:

🟢 Todas actualizadas → ✅ bajo riesgo.

🟡 Algunas obsoletas → ⚠️ potencial encadenamiento.

🔴 Librerías con CVEs conocidas → 🔥 vector de entrada directo.

💡 jQuery < 3.5.0 = XSS autoejecutable en muchos casos.

🛡️ 8. Verificación de mapas fuente (.map)

✅ Prueba clave:

Intentá acceder a *.js.map:

https://target.com/js/main.js.map


Interpretación:

🟢 No existe o inaccesible → ✅ bien configurado.

🟡 Existe pero minificado → ⚠️ recon útil.

🔴 Código fuente completo expuesto → 🔥 mapa completo de la app.

- Un .map filtrado es equivalente a leer el repositorio original 😳

📊 Resultado final — Cómo interpretarlo
Estado final	Significado
🟢 Todos verdes	✅ Análisis de JS sin hallazgos.
🟡 Alguno amarillo	⚠️ superficie abierta, vale la pena profundizar.
🔴 Cualquiera rojo	🔥 JS vulnerable o con info crítica filtrada.

- Pro tip Myrmidón:
El análisis de JS suele ser el paso más infravalorado… pero el más rentable. Así nacen muchas cadenas:

JS con endpoints → SSRF / IDOR

JS con claves → acceso a APIs internas

JS con sinks → DOM XSS

JS con lógica → bypass de roles

JS con rutas → LFI o RFI interno


- Ejemplo real (impacto crítico):

Archivo main.js:

fetch("/api/admin/delete?user=" + userId);


- Hallazgo: parámetro user controlado → explotación de IDOR crítico sin autenticación.
BONUS: Muchos programas bug bounty pagan más por bugs descubiertos en .js que por vulnerabilidades clásicas, porque implican acceso profundo al sistema sin interacción directa.
```


 <br>

<picture> <img src="https://user-images.githubusercontent.com/74038190/212284115-f47cd8ff-2ffb-4b04-b5bf-4d1c14c0247f.gif" width ="1050" > </picture>
<br>

### <picture> <img src = "https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExc3YwbG9zbmU1amprdTJsbmxzYnpobzd5eGtnazB6b2FmdnllaTRhZyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/h8UlsEpqiCISTKUzvz/giphy.gif" width = 80px>  </picture> “Gestor de Informes — organiza, filtra y abre. Tu base de bug bounty, offline y al instante.”
<br>


<picture> <img src="https://user-images.githubusercontent.com/74038190/212284115-f47cd8ff-2ffb-4b04-b5bf-4d1c14c0247f.gif" width ="1050" > </picture>
